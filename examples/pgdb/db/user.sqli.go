package db

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/Dionid/sqli"
	"github.com/google/uuid"
)

type UserTable struct {
	sqli.Table
	ID        sqli.Column[uuid.UUID]
	Name      sqli.Column[string]
	Email     sqli.Column[string]
	Password  sqli.Column[string]
	CreatedAt sqli.Column[time.Time]
	UpdatedAt sqli.Column[sql.NullTime]
	Role      sqli.Column[string]
}

func (t UserTable) As(alias string) UserTable {
	t.Table.TableAlias = fmt.Sprintf(`"%s"`, alias)
	t.ID = sqli.NewColumnWithAlias[uuid.UUID](t.Table, t.ID.ColumnName, t.ID.ColumnAlias)
	t.Name = sqli.NewColumnWithAlias[string](t.Table, t.Name.ColumnName, t.Name.ColumnAlias)
	t.Email = sqli.NewColumnWithAlias[string](t.Table, t.Email.ColumnName, t.Email.ColumnAlias)
	t.Password = sqli.NewColumnWithAlias[string](t.Table, t.Password.ColumnName, t.Password.ColumnAlias)
	t.CreatedAt = sqli.NewColumnWithAlias[time.Time](t.Table, t.CreatedAt.ColumnName, t.CreatedAt.ColumnAlias)
	t.UpdatedAt = sqli.NewColumnWithAlias[sql.NullTime](t.Table, t.UpdatedAt.ColumnName, t.UpdatedAt.ColumnAlias)
	t.Role = sqli.NewColumnWithAlias[string](t.Table, t.Role.ColumnName, t.Role.ColumnAlias)

	return t
}

var UserMeta = sqli.Table{
	TableName:  `"user"`,
	TableAlias: `"user"`,
	ColumnNames: map[string]bool{
		`"id"`:         true,
		`"name"`:       true,
		`"email"`:      true,
		`"password"`:   true,
		`"created_at"`: true,
		`"updated_at"`: true,
		`"role"`:       true,
	},
}

var User = UserTable{
	Table:     UserMeta,
	ID:        sqli.NewColumn[uuid.UUID](UserMeta, `"id"`),
	Name:      sqli.NewColumn[string](UserMeta, `"name"`),
	Email:     sqli.NewColumn[string](UserMeta, `"email"`),
	Password:  sqli.NewColumn[string](UserMeta, `"password"`),
	CreatedAt: sqli.NewColumn[time.Time](UserMeta, `"created_at"`),
	UpdatedAt: sqli.NewColumn[sql.NullTime](UserMeta, `"updated_at"`),
	Role:      sqli.NewColumn[string](UserMeta, `"role"`),
}

// # Constants

// # Columns Types
type (
	UserIDT        = uuid.UUID
	UserNameT      = string
	UserEmailT     = string
	UserPasswordT  = string
	UserCreatedAtT = time.Time
	UserUpdatedAtT = sql.NullTime
	UserRoleT      = string
)

// # Columns Names
const (
	UserID        = `"id"`
	UserName      = `"name"`
	UserEmail     = `"email"`
	UserPassword  = `"password"`
	UserCreatedAt = `"created_at"`
	UserUpdatedAt = `"updated_at"`
	UserRole      = `"role"`
)

// # Model

type UserModel struct {
	ID        uuid.UUID    `json:"id" db:"id"`
	Name      string       `json:"name" db:"name"`
	Email     string       `json:"email" db:"email"`
	Password  string       `json:"password" db:"password"`
	CreatedAt time.Time    `json:"created_at" db:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at" db:"updated_at"`
	Role      string       `json:"role" db:"role"`
}

func NewUserModel(
	ID uuid.UUID,
	Name string,
	Email string,
	Password string,
	CreatedAt time.Time,
	UpdatedAt sql.NullTime,
	Role string,
) *UserModel {
	return &UserModel{
		ID:        ID,
		Name:      Name,
		Email:     Email,
		Password:  Password,
		CreatedAt: CreatedAt,
		UpdatedAt: UpdatedAt,
		Role:      Role,
	}
}

// ## Insertable

type InsertableUserModel struct {
	ID        uuid.UUID    `json:"id" db:"id"`
	Name      string       `json:"name" db:"name"`
	Email     string       `json:"email" db:"email"`
	Password  string       `json:"password" db:"password"`
	CreatedAt time.Time    `json:"created_at" db:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at" db:"updated_at"`
	Role      string       `json:"role" db:"role"`
}

func NewInsertableUserModel(
	ID uuid.UUID,
	Name string,
	Email string,
	Password string,
	CreatedAt time.Time,
	UpdatedAt sql.NullTime,
	Role string,
) *InsertableUserModel {
	return &InsertableUserModel{
		ID:        ID,
		Name:      Name,
		Email:     Email,
		Password:  Password,
		CreatedAt: CreatedAt,
		UpdatedAt: UpdatedAt,
		Role:      Role,
	}
}

func InsertIntoUser(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableUserModel,
) (sql.Result, error) {
	if modelsList == nil {
		return nil, errors.New("InsertableUserModel is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(User.ID, model.ID),
			sqli.VALUE(User.Name, model.Name),
			sqli.VALUE(User.Email, model.Email),
			sqli.VALUE(User.Password, model.Password),
			sqli.VALUE(User.CreatedAt, model.CreatedAt),
			sqli.VALUE(User.UpdatedAt, model.UpdatedAt),
			sqli.VALUE(User.Role, model.Role),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			User,
			User.ID,
			User.Name,
			User.Email,
			User.Password,
			User.CreatedAt,
			User.UpdatedAt,
			User.Role,
		),
		sqli.VALUES(
			valueSetList...,
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoUserReturningAll(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableUserModel,
) (*UserModel, error) {
	if modelsList == nil {
		return nil, errors.New("InsertableUserModel is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(User.ID, model.ID),
			sqli.VALUE(User.Name, model.Name),
			sqli.VALUE(User.Email, model.Email),
			sqli.VALUE(User.Password, model.Password),
			sqli.VALUE(User.CreatedAt, model.CreatedAt),
			sqli.VALUE(User.UpdatedAt, model.UpdatedAt),
			sqli.VALUE(User.Role, model.Role),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			User,
			User.ID,
			User.Name,
			User.Email,
			User.Password,
			User.CreatedAt,
			User.UpdatedAt,
			User.Role,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(User.AllColumns()),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var model UserModel
	err = row.Scan(
		&model.ID,
		&model.Name,
		&model.Email,
		&model.Password,
		&model.CreatedAt,
		&model.UpdatedAt,
		&model.Role,
	)
	if err != nil {
		return nil, err
	}

	return &model, nil
}

// ## Updatable

type UpdatableUserModel struct {
	ID        *uuid.UUID    `json:"id" db:"id"`
	Name      *string       `json:"name" db:"name"`
	Email     *string       `json:"email" db:"email"`
	Password  *string       `json:"password" db:"password"`
	CreatedAt *time.Time    `json:"created_at" db:"created_at"`
	UpdatedAt *sql.NullTime `json:"updated_at" db:"updated_at"`
	Role      *string       `json:"role" db:"role"`
}

func NewUpdatableUserModel(
	ID *uuid.UUID,
	Name *string,
	Email *string,
	Password *string,
	CreatedAt *time.Time,
	UpdatedAt *sql.NullTime,
	Role *string,
) *UpdatableUserModel {
	return &UpdatableUserModel{
		ID,
		Name,
		Email,
		Password,
		CreatedAt,
		UpdatedAt,
		Role,
	}
}

// ## Select by Email
func SelectUserByEmail(
	ctx context.Context,
	db DB,
	Email string,
) (*UserModel, error) {
	query, err := sqli.Query(
		sqli.SELECT(
			User.AllColumns(),
		),
		sqli.FROM(User),
		sqli.WHERE(
			sqli.EQUAL(User.Email, Email),
		),
		sqli.LIMIT(1),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	model := &UserModel{}
	err = row.Scan(
		&model.ID,
		&model.Name,
		&model.Email,
		&model.Password,
		&model.CreatedAt,
		&model.UpdatedAt,
		&model.Role,
	)
	if err != nil {
		return nil, err
	}

	return model, nil
}

// ## Delete by Email
func DeleteFromUserByEmail(
	ctx context.Context,
	db DB,
	Email string,
) (sql.Result, error) {
	query, err := sqli.Query(
		sqli.DELETE_FROM(
			User,
		),
		sqli.WHERE(
			sqli.EQUAL(User.Email, Email),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoUserReturningEmail(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableUserModel,
) (*string, error) {
	if modelsList == nil {
		return nil, errors.New("InsertIntoUserReturningEmailResult is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(User.ID, model.ID),
			sqli.VALUE(User.Name, model.Name),
			sqli.VALUE(User.Email, model.Email),
			sqli.VALUE(User.Password, model.Password),
			sqli.VALUE(User.CreatedAt, model.CreatedAt),
			sqli.VALUE(User.UpdatedAt, model.UpdatedAt),
			sqli.VALUE(User.Role, model.Role),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			User,
			User.ID,
			User.Name,
			User.Email,
			User.Password,
			User.CreatedAt,
			User.UpdatedAt,
			User.Role,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(
			User.Email,
		),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var returning string
	err = row.Scan(&returning)
	if err != nil {
		return nil, err
	}

	return &returning, nil
}

// # Update
// ## Update by Email
func UpdateUserByEmail(
	ctx context.Context,
	db DB,
	Email string,
	updatableModel *UpdatableUserModel,
) (sql.Result, error) {
	valuesSetList := []sqli.Statement{}

	if updatableModel.ID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(User.ID, *updatableModel.ID))
	}
	if updatableModel.Name != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(User.Name, *updatableModel.Name))
	}
	if updatableModel.Email != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(User.Email, *updatableModel.Email))
	}
	if updatableModel.Password != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(User.Password, *updatableModel.Password))
	}
	if updatableModel.CreatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(User.CreatedAt, *updatableModel.CreatedAt))
	}
	if updatableModel.UpdatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(User.UpdatedAt, *updatableModel.UpdatedAt))
	}
	if updatableModel.Role != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(User.Role, *updatableModel.Role))
	}

	query, err := sqli.Query(
		sqli.UPDATE(
			User,
		),
		sqli.SET(
			valuesSetList...,
		),
		sqli.WHERE(
			sqli.EQUAL(User.Email, Email),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

// ## Select by ID
func SelectUserByID(
	ctx context.Context,
	db DB,
	ID uuid.UUID,
) (*UserModel, error) {
	query, err := sqli.Query(
		sqli.SELECT(
			User.AllColumns(),
		),
		sqli.FROM(User),
		sqli.WHERE(
			sqli.EQUAL(User.ID, ID),
		),
		sqli.LIMIT(1),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	model := &UserModel{}
	err = row.Scan(
		&model.ID,
		&model.Name,
		&model.Email,
		&model.Password,
		&model.CreatedAt,
		&model.UpdatedAt,
		&model.Role,
	)
	if err != nil {
		return nil, err
	}

	return model, nil
}

// ## Delete by ID
func DeleteFromUserByID(
	ctx context.Context,
	db DB,
	ID uuid.UUID,
) (sql.Result, error) {
	query, err := sqli.Query(
		sqli.DELETE_FROM(
			User,
		),
		sqli.WHERE(
			sqli.EQUAL(User.ID, ID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoUserReturningID(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableUserModel,
) (*uuid.UUID, error) {
	if modelsList == nil {
		return nil, errors.New("InsertIntoUserReturningIDResult is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(User.ID, model.ID),
			sqli.VALUE(User.Name, model.Name),
			sqli.VALUE(User.Email, model.Email),
			sqli.VALUE(User.Password, model.Password),
			sqli.VALUE(User.CreatedAt, model.CreatedAt),
			sqli.VALUE(User.UpdatedAt, model.UpdatedAt),
			sqli.VALUE(User.Role, model.Role),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			User,
			User.ID,
			User.Name,
			User.Email,
			User.Password,
			User.CreatedAt,
			User.UpdatedAt,
			User.Role,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(
			User.ID,
		),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var returning uuid.UUID
	err = row.Scan(&returning)
	if err != nil {
		return nil, err
	}

	return &returning, nil
}

// # Update
// ## Update by ID
func UpdateUserByID(
	ctx context.Context,
	db DB,
	ID uuid.UUID,
	updatableModel *UpdatableUserModel,
) (sql.Result, error) {
	valuesSetList := []sqli.Statement{}

	if updatableModel.ID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(User.ID, *updatableModel.ID))
	}
	if updatableModel.Name != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(User.Name, *updatableModel.Name))
	}
	if updatableModel.Email != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(User.Email, *updatableModel.Email))
	}
	if updatableModel.Password != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(User.Password, *updatableModel.Password))
	}
	if updatableModel.CreatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(User.CreatedAt, *updatableModel.CreatedAt))
	}
	if updatableModel.UpdatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(User.UpdatedAt, *updatableModel.UpdatedAt))
	}
	if updatableModel.Role != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(User.Role, *updatableModel.Role))
	}

	query, err := sqli.Query(
		sqli.UPDATE(
			User,
		),
		sqli.SET(
			valuesSetList...,
		),
		sqli.WHERE(
			sqli.EQUAL(User.ID, ID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}
