package db

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/Dionid/sqli"
)

type GooseDbVersionTableSt struct {
	sqli.Table
	ID        sqli.Column[int]
	VersionID sqli.Column[int64]
	IsApplied sqli.Column[bool]
	Tstamp    sqli.Column[time.Time]
}

func (t GooseDbVersionTableSt) As(alias string) GooseDbVersionTableSt {
	t.Table.TableAlias = fmt.Sprintf(`"%s"`, alias)
	t.ID = sqli.NewColumnWithAlias[int](t.Table, t.ID.ColumnName, t.ID.ColumnAlias)
	t.VersionID = sqli.NewColumnWithAlias[int64](t.Table, t.VersionID.ColumnName, t.VersionID.ColumnAlias)
	t.IsApplied = sqli.NewColumnWithAlias[bool](t.Table, t.IsApplied.ColumnName, t.IsApplied.ColumnAlias)
	t.Tstamp = sqli.NewColumnWithAlias[time.Time](t.Table, t.Tstamp.ColumnName, t.Tstamp.ColumnAlias)

	return t
}

var GooseDbVersionTableBase = sqli.Table{
	TableName:  `"goose_db_version"`,
	TableAlias: `"goose_db_version"`,
}

var GooseDbVersionTable = GooseDbVersionTableSt{
	Table:     GooseDbVersionTableBase,
	ID:        sqli.NewColumn[int](GooseDbVersionTableBase, `"id"`),
	VersionID: sqli.NewColumn[int64](GooseDbVersionTableBase, `"version_id"`),
	IsApplied: sqli.NewColumn[bool](GooseDbVersionTableBase, `"is_applied"`),
	Tstamp:    sqli.NewColumn[time.Time](GooseDbVersionTableBase, `"tstamp"`),
}

// # Constants

// # Columns Types (CT)
type (
	GooseDbVersionIDCT        = int
	GooseDbVersionVersionIDCT = int64
	GooseDbVersionIsAppliedCT = bool
	GooseDbVersionTstampCT    = time.Time
)

// # Columns Names (CN)
const (
	GooseDbVersionIDCN        = `"id"`
	GooseDbVersionVersionIDCN = `"version_id"`
	GooseDbVersionIsAppliedCN = `"is_applied"`
	GooseDbVersionTstampCN    = `"tstamp"`
)

// # Model

type GooseDbVersionModel struct {
	ID        int       `json:"id" db:"id"`
	VersionID int64     `json:"version_id" db:"version_id"`
	IsApplied bool      `json:"is_applied" db:"is_applied"`
	Tstamp    time.Time `json:"tstamp" db:"tstamp"`
}

func NewGooseDbVersionModel(
	ID int,
	VersionID int64,
	IsApplied bool,
	Tstamp time.Time,
) *GooseDbVersionModel {
	return &GooseDbVersionModel{
		ID:        ID,
		VersionID: VersionID,
		IsApplied: IsApplied,
		Tstamp:    Tstamp,
	}
}

// ## Insertable

type InsertableGooseDbVersionModel struct {
	VersionID int64     `json:"version_id" db:"version_id"`
	IsApplied bool      `json:"is_applied" db:"is_applied"`
	Tstamp    time.Time `json:"tstamp" db:"tstamp"`
}

func NewInsertableGooseDbVersionModel(
	VersionID int64,
	IsApplied bool,
	Tstamp time.Time,
) *InsertableGooseDbVersionModel {
	return &InsertableGooseDbVersionModel{
		VersionID: VersionID,
		IsApplied: IsApplied,
		Tstamp:    Tstamp,
	}
}

func InsertIntoGooseDbVersionTable(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableGooseDbVersionModel,
) (sql.Result, error) {
	if modelsList == nil {
		return nil, errors.New("InsertableGooseDbVersionModel is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(GooseDbVersionTable.VersionID, model.VersionID),
			sqli.VALUE(GooseDbVersionTable.IsApplied, model.IsApplied),
			sqli.VALUE(GooseDbVersionTable.Tstamp, model.Tstamp),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			GooseDbVersionTable,
			GooseDbVersionTable.VersionID,
			GooseDbVersionTable.IsApplied,
			GooseDbVersionTable.Tstamp,
		),
		sqli.VALUES(
			valueSetList...,
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoGooseDbVersionTableReturningAll(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableGooseDbVersionModel,
) (*GooseDbVersionModel, error) {
	if modelsList == nil {
		return nil, errors.New("InsertableGooseDbVersionModel is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(GooseDbVersionTable.VersionID, model.VersionID),
			sqli.VALUE(GooseDbVersionTable.IsApplied, model.IsApplied),
			sqli.VALUE(GooseDbVersionTable.Tstamp, model.Tstamp),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			GooseDbVersionTable,
			GooseDbVersionTable.VersionID,
			GooseDbVersionTable.IsApplied,
			GooseDbVersionTable.Tstamp,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(GooseDbVersionTable.AllColumns()),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var model GooseDbVersionModel
	err = row.Scan(
		&model.ID,
		&model.VersionID,
		&model.IsApplied,
		&model.Tstamp,
	)
	if err != nil {
		return nil, err
	}

	return &model, nil
}

// ## Updatable

type UpdatableGooseDbVersionModel struct {
	ID        *int       `json:"id" db:"id"`
	VersionID *int64     `json:"version_id" db:"version_id"`
	IsApplied *bool      `json:"is_applied" db:"is_applied"`
	Tstamp    *time.Time `json:"tstamp" db:"tstamp"`
}

func NewUpdatableGooseDbVersionModel(
	ID *int,
	VersionID *int64,
	IsApplied *bool,
	Tstamp *time.Time,
) *UpdatableGooseDbVersionModel {
	return &UpdatableGooseDbVersionModel{
		ID,
		VersionID,
		IsApplied,
		Tstamp,
	}
}

// ## Select by ID
func SelectGooseDbVersionTableByID(
	ctx context.Context,
	db DB,
	ID int,
) (*GooseDbVersionModel, error) {
	query, err := sqli.Query(
		sqli.SELECT(
			GooseDbVersionTable.AllColumns(),
		),
		sqli.FROM(GooseDbVersionTable),
		sqli.WHERE(
			sqli.EQUAL(GooseDbVersionTable.ID, ID),
		),
		sqli.LIMIT(1),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	model := &GooseDbVersionModel{}
	err = row.Scan(
		&model.ID,
		&model.VersionID,
		&model.IsApplied,
		&model.Tstamp,
	)
	if err != nil {
		return nil, err
	}

	return model, nil
}

// ## Delete by ID
func DeleteFromGooseDbVersionTableByID(
	ctx context.Context,
	db DB,
	ID int,
) (sql.Result, error) {
	query, err := sqli.Query(
		sqli.DELETE_FROM(
			GooseDbVersionTable,
		),
		sqli.WHERE(
			sqli.EQUAL(GooseDbVersionTable.ID, ID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoGooseDbVersionTableReturningID(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableGooseDbVersionModel,
) (*int, error) {
	if modelsList == nil {
		return nil, errors.New("InsertIntoGooseDbVersionTableReturningIDResult is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(GooseDbVersionTable.VersionID, model.VersionID),
			sqli.VALUE(GooseDbVersionTable.IsApplied, model.IsApplied),
			sqli.VALUE(GooseDbVersionTable.Tstamp, model.Tstamp),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			GooseDbVersionTable,
			GooseDbVersionTable.VersionID,
			GooseDbVersionTable.IsApplied,
			GooseDbVersionTable.Tstamp,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(
			GooseDbVersionTable.ID,
		),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var returning int
	err = row.Scan(&returning)
	if err != nil {
		return nil, err
	}

	return &returning, nil
}

// # Update
// ## Update by ID
func UpdateGooseDbVersionTableByID(
	ctx context.Context,
	db DB,
	ID int,
	updatableModel *UpdatableGooseDbVersionModel,
) (sql.Result, error) {
	valuesSetList := []sqli.Statement{}

	if updatableModel.ID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(GooseDbVersionTable.ID, *updatableModel.ID))
	}
	if updatableModel.VersionID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(GooseDbVersionTable.VersionID, *updatableModel.VersionID))
	}
	if updatableModel.IsApplied != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(GooseDbVersionTable.IsApplied, *updatableModel.IsApplied))
	}
	if updatableModel.Tstamp != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(GooseDbVersionTable.Tstamp, *updatableModel.Tstamp))
	}

	query, err := sqli.Query(
		sqli.UPDATE(
			GooseDbVersionTable,
		),
		sqli.SET(
			valuesSetList...,
		),
		sqli.WHERE(
			sqli.EQUAL(GooseDbVersionTable.ID, ID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}
