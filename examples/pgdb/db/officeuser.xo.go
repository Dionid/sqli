package db

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/Dionid/sqli"
	"github.com/google/uuid"
)

type OfficeUserTableSt struct {
	sqli.Table
	OfficeID  sqli.Column[uuid.UUID]
	UserID    sqli.Column[uuid.UUID]
	CreatedAt sqli.Column[time.Time]
	UpdatedAt sqli.Column[sql.NullTime]
}

func (t OfficeUserTableSt) As(alias string) OfficeUserTableSt {
	t.Table.TableAlias = fmt.Sprintf(`"%s"`, alias)
	t.OfficeID = sqli.NewColumnWithAlias[uuid.UUID](t.Table, t.OfficeID.ColumnName, t.OfficeID.ColumnAlias)
	t.UserID = sqli.NewColumnWithAlias[uuid.UUID](t.Table, t.UserID.ColumnName, t.UserID.ColumnAlias)
	t.CreatedAt = sqli.NewColumnWithAlias[time.Time](t.Table, t.CreatedAt.ColumnName, t.CreatedAt.ColumnAlias)
	t.UpdatedAt = sqli.NewColumnWithAlias[sql.NullTime](t.Table, t.UpdatedAt.ColumnName, t.UpdatedAt.ColumnAlias)

	return t
}

var OfficeUserTableBase = sqli.Table{
	TableName:  `"office_user"`,
	TableAlias: `"office_user"`,
}

var OfficeUserTable = OfficeUserTableSt{
	Table:     OfficeUserTableBase,
	OfficeID:  sqli.NewColumn[uuid.UUID](OfficeUserTableBase, `"office_id"`),
	UserID:    sqli.NewColumn[uuid.UUID](OfficeUserTableBase, `"user_id"`),
	CreatedAt: sqli.NewColumn[time.Time](OfficeUserTableBase, `"created_at"`),
	UpdatedAt: sqli.NewColumn[sql.NullTime](OfficeUserTableBase, `"updated_at"`),
}

// # Constants

type (
	OfficeUserOfficeIDCT  = uuid.UUID
	OfficeUserUserIDCT    = uuid.UUID
	OfficeUserCreatedAtCT = time.Time
	OfficeUserUpdatedAtCT = sql.NullTime
)

const (
	OfficeUserOfficeIDCN  = `"office_id"`
	OfficeUserUserIDCN    = `"user_id"`
	OfficeUserCreatedAtCN = `"created_at"`
	OfficeUserUpdatedAtCN = `"updated_at"`
)

// # Model

type OfficeUserModel struct {
	OfficeID  uuid.UUID    `json:"office_id" db:"office_id"`
	UserID    uuid.UUID    `json:"user_id" db:"user_id"`
	CreatedAt time.Time    `json:"created_at" db:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at" db:"updated_at"`
}

func NewOfficeUserModel(
	OfficeID uuid.UUID,
	UserID uuid.UUID,
	CreatedAt time.Time,
	UpdatedAt sql.NullTime,
) *OfficeUserModel {
	return &OfficeUserModel{
		OfficeID:  OfficeID,
		UserID:    UserID,
		CreatedAt: CreatedAt,
		UpdatedAt: UpdatedAt,
	}
}

// ## Insertable

type InsertableOfficeUserModel struct {
	OfficeID  uuid.UUID    `json:"office_id" db:"office_id"`
	UserID    uuid.UUID    `json:"user_id" db:"user_id"`
	CreatedAt time.Time    `json:"created_at" db:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at" db:"updated_at"`
}

func NewInsertableOfficeUserModel(
	OfficeID uuid.UUID,
	UserID uuid.UUID,
	CreatedAt time.Time,
	UpdatedAt sql.NullTime,
) *InsertableOfficeUserModel {
	return &InsertableOfficeUserModel{
		OfficeID:  OfficeID,
		UserID:    UserID,
		CreatedAt: CreatedAt,
		UpdatedAt: UpdatedAt,
	}
}

func InsertIntoOfficeUserTable(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableOfficeUserModel,
) (sql.Result, error) {
	if modelsList == nil {
		return nil, errors.New("InsertableOfficeUserModel is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(OfficeUserTable.OfficeID, model.OfficeID),
			sqli.VALUE(OfficeUserTable.UserID, model.UserID),
			sqli.VALUE(OfficeUserTable.CreatedAt, model.CreatedAt),
			sqli.VALUE(OfficeUserTable.UpdatedAt, model.UpdatedAt),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			OfficeUserTable,
			OfficeUserTable.OfficeID,
			OfficeUserTable.UserID,
			OfficeUserTable.CreatedAt,
			OfficeUserTable.UpdatedAt,
		),
		sqli.VALUES(
			valueSetList...,
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoOfficeUserTableReturningAll(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableOfficeUserModel,
) (*OfficeUserModel, error) {
	if modelsList == nil {
		return nil, errors.New("InsertableOfficeUserModel is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(OfficeUserTable.OfficeID, model.OfficeID),
			sqli.VALUE(OfficeUserTable.UserID, model.UserID),
			sqli.VALUE(OfficeUserTable.CreatedAt, model.CreatedAt),
			sqli.VALUE(OfficeUserTable.UpdatedAt, model.UpdatedAt),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			OfficeUserTable,
			OfficeUserTable.OfficeID,
			OfficeUserTable.UserID,
			OfficeUserTable.CreatedAt,
			OfficeUserTable.UpdatedAt,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(OfficeUserTable.AllColumns()),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var model OfficeUserModel
	err = row.Scan(
		&model.OfficeID,
		&model.UserID,
		&model.CreatedAt,
		&model.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &model, nil
}

// ## Updatable

type UpdatableOfficeUserModel struct {
	OfficeID  *uuid.UUID    `json:"office_id" db:"office_id"`
	UserID    *uuid.UUID    `json:"user_id" db:"user_id"`
	CreatedAt *time.Time    `json:"created_at" db:"created_at"`
	UpdatedAt *sql.NullTime `json:"updated_at" db:"updated_at"`
}

func NewUpdatableOfficeUserModel(
	OfficeID *uuid.UUID,
	UserID *uuid.UUID,
	CreatedAt *time.Time,
	UpdatedAt *sql.NullTime,
) *UpdatableOfficeUserModel {
	return &UpdatableOfficeUserModel{
		OfficeID,
		UserID,
		CreatedAt,
		UpdatedAt,
	}
}

// ## Select by compound
func SelectFromOfficeUserTableByOfficeIDUserID(
	ctx context.Context,
	db DB,
	OfficeID uuid.UUID,
	UserID uuid.UUID,
) (*OfficeUserModel, error) {
	query, err := sqli.Query(
		sqli.SELECT(
			OfficeUserTable.AllColumns(),
		),
		sqli.FROM(OfficeUserTable),
		sqli.WHERE(
			sqli.AND(
				sqli.EQUAL(OfficeUserTable.OfficeID, OfficeID),
				sqli.EQUAL(OfficeUserTable.UserID, UserID),
			),
		),
		sqli.LIMIT(1),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	model := &OfficeUserModel{}
	err = row.Scan(
		&model.OfficeID,
		&model.UserID,
		&model.CreatedAt,
		&model.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return model, nil
}

// ## Delete by compound
func DeleteFromOfficeUserTableByOfficeIDUserID(
	ctx context.Context,
	db DB,
	OfficeID uuid.UUID,
	UserID uuid.UUID,
) (sql.Result, error) {
	query, err := sqli.Query(
		sqli.DELETE_FROM(
			OfficeUserTable,
		),
		sqli.WHERE(
			sqli.AND(
				sqli.EQUAL(OfficeUserTable.OfficeID, OfficeID),
				sqli.EQUAL(OfficeUserTable.UserID, UserID),
			),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

// ## Update by compound
func UpdateOfficeUserTableByOfficeIDUserID(
	ctx context.Context,
	db DB,
	updatableModel *UpdatableOfficeUserModel,
	OfficeID uuid.UUID,
	UserID uuid.UUID,
) (sql.Result, error) {
	valuesSetList := []sqli.Statement{}

	if updatableModel.OfficeID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUserTable.OfficeID, *updatableModel.OfficeID))
	}
	if updatableModel.UserID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUserTable.UserID, *updatableModel.UserID))
	}
	if updatableModel.CreatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUserTable.CreatedAt, *updatableModel.CreatedAt))
	}
	if updatableModel.UpdatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUserTable.UpdatedAt, *updatableModel.UpdatedAt))
	}

	query, err := sqli.Query(
		sqli.UPDATE(
			OfficeUserTable,
		),
		sqli.SET(
			valuesSetList...,
		),
		sqli.WHERE(
			sqli.AND(
				sqli.EQUAL(OfficeUserTable.OfficeID, OfficeID),
				sqli.EQUAL(OfficeUserTable.UserID, UserID),
			),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

type InsertIntoOfficeUserTableReturningOfficeIDUserIDResult struct {
	OfficeID uuid.UUID `json:"office_id" db:"office_id"`
	UserID   uuid.UUID `json:"user_id" db:"user_id"`
}

func InsertIntoOfficeUserTableReturningOfficeIDUserID(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableOfficeUserModel,
) (*InsertIntoOfficeUserTableReturningOfficeIDUserIDResult, error) {
	if modelsList == nil {
		return nil, errors.New("InsertIntoOfficeUserTableReturningOfficeIDUserIDResult is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(OfficeUserTable.OfficeID, model.OfficeID),
			sqli.VALUE(OfficeUserTable.UserID, model.UserID),
			sqli.VALUE(OfficeUserTable.CreatedAt, model.CreatedAt),
			sqli.VALUE(OfficeUserTable.UpdatedAt, model.UpdatedAt),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			OfficeUserTable,
			OfficeUserTable.OfficeID,
			OfficeUserTable.UserID,
			OfficeUserTable.CreatedAt,
			OfficeUserTable.UpdatedAt,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(
			OfficeUserTable.OfficeID,
			OfficeUserTable.UserID,
		),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	returning := &InsertIntoOfficeUserTableReturningOfficeIDUserIDResult{}
	err = row.Scan(returning)
	if err != nil {
		return nil, err
	}

	return returning, nil
}

// ## Select by OfficeID
func SelectOfficeUserTableByOfficeID(
	ctx context.Context,
	db DB,
	OfficeID uuid.UUID,
) ([]*OfficeUserModel, error) {
	query, err := sqli.Query(
		sqli.SELECT(
			OfficeUserTable.AllColumns(),
		),
		sqli.FROM(OfficeUserTable),
		sqli.WHERE(
			sqli.EQUAL(OfficeUserTable.OfficeID, OfficeID),
		),
	)
	if err != nil {
		return nil, err
	}

	rows, err := db.QueryxContext(ctx, query.SQL, query.Args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*OfficeUserModel
	for rows.Next() {
		item := &OfficeUserModel{}
		if err := rows.Scan(
			item,
		); err != nil {
			return nil, err
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// ## Select by UserID
func SelectOfficeUserTableByUserID(
	ctx context.Context,
	db DB,
	UserID uuid.UUID,
) ([]*OfficeUserModel, error) {
	query, err := sqli.Query(
		sqli.SELECT(
			OfficeUserTable.AllColumns(),
		),
		sqli.FROM(OfficeUserTable),
		sqli.WHERE(
			sqli.EQUAL(OfficeUserTable.UserID, UserID),
		),
	)
	if err != nil {
		return nil, err
	}

	rows, err := db.QueryxContext(ctx, query.SQL, query.Args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*OfficeUserModel
	for rows.Next() {
		item := &OfficeUserModel{}
		if err := rows.Scan(
			item,
		); err != nil {
			return nil, err
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// ## Delete by OfficeID
func DeleteFromOfficeUserTableByOfficeID(
	ctx context.Context,
	db DB,
	OfficeID uuid.UUID,
) (sql.Result, error) {
	query, err := sqli.Query(
		sqli.DELETE_FROM(
			OfficeUserTable,
		),
		sqli.WHERE(
			sqli.EQUAL(OfficeUserTable.OfficeID, OfficeID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoOfficeUserTableReturningOfficeID(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableOfficeUserModel,
) (*uuid.UUID, error) {
	if modelsList == nil {
		return nil, errors.New("InsertIntoOfficeUserTableReturningOfficeIDUserIDResult is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(OfficeUserTable.OfficeID, model.OfficeID),
			sqli.VALUE(OfficeUserTable.UserID, model.UserID),
			sqli.VALUE(OfficeUserTable.CreatedAt, model.CreatedAt),
			sqli.VALUE(OfficeUserTable.UpdatedAt, model.UpdatedAt),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			OfficeUserTable,
			OfficeUserTable.OfficeID,
			OfficeUserTable.UserID,
			OfficeUserTable.CreatedAt,
			OfficeUserTable.UpdatedAt,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(
			OfficeUserTable.OfficeID,
		),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var returning uuid.UUID
	err = row.Scan(&returning)
	if err != nil {
		return nil, err
	}

	return &returning, nil
}

// # Update
// ## Update by OfficeID
func UpdateOfficeUserTableByOfficeID(
	ctx context.Context,
	db DB,
	updatableModel *UpdatableOfficeUserModel,
	OfficeID uuid.UUID,
) (sql.Result, error) {
	valuesSetList := []sqli.Statement{}

	if updatableModel.OfficeID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUserTable.OfficeID, *updatableModel.OfficeID))
	}
	if updatableModel.UserID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUserTable.UserID, *updatableModel.UserID))
	}
	if updatableModel.CreatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUserTable.CreatedAt, *updatableModel.CreatedAt))
	}
	if updatableModel.UpdatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUserTable.UpdatedAt, *updatableModel.UpdatedAt))
	}

	query, err := sqli.Query(
		sqli.UPDATE(
			OfficeUserTable,
		),
		sqli.SET(
			valuesSetList...,
		),
		sqli.WHERE(
			sqli.EQUAL(OfficeUserTable.OfficeID, OfficeID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

// ## Delete by UserID
func DeleteFromOfficeUserTableByUserID(
	ctx context.Context,
	db DB,
	UserID uuid.UUID,
) (sql.Result, error) {
	query, err := sqli.Query(
		sqli.DELETE_FROM(
			OfficeUserTable,
		),
		sqli.WHERE(
			sqli.EQUAL(OfficeUserTable.UserID, UserID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoOfficeUserTableReturningUserID(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableOfficeUserModel,
) (*uuid.UUID, error) {
	if modelsList == nil {
		return nil, errors.New("InsertIntoOfficeUserTableReturningOfficeIDUserIDResult is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(OfficeUserTable.OfficeID, model.OfficeID),
			sqli.VALUE(OfficeUserTable.UserID, model.UserID),
			sqli.VALUE(OfficeUserTable.CreatedAt, model.CreatedAt),
			sqli.VALUE(OfficeUserTable.UpdatedAt, model.UpdatedAt),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			OfficeUserTable,
			OfficeUserTable.OfficeID,
			OfficeUserTable.UserID,
			OfficeUserTable.CreatedAt,
			OfficeUserTable.UpdatedAt,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(
			OfficeUserTable.UserID,
		),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var returning uuid.UUID
	err = row.Scan(&returning)
	if err != nil {
		return nil, err
	}

	return &returning, nil
}

// # Update
// ## Update by UserID
func UpdateOfficeUserTableByUserID(
	ctx context.Context,
	db DB,
	updatableModel *UpdatableOfficeUserModel,
	UserID uuid.UUID,
) (sql.Result, error) {
	valuesSetList := []sqli.Statement{}

	if updatableModel.OfficeID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUserTable.OfficeID, *updatableModel.OfficeID))
	}
	if updatableModel.UserID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUserTable.UserID, *updatableModel.UserID))
	}
	if updatableModel.CreatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUserTable.CreatedAt, *updatableModel.CreatedAt))
	}
	if updatableModel.UpdatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUserTable.UpdatedAt, *updatableModel.UpdatedAt))
	}

	query, err := sqli.Query(
		sqli.UPDATE(
			OfficeUserTable,
		),
		sqli.SET(
			valuesSetList...,
		),
		sqli.WHERE(
			sqli.EQUAL(OfficeUserTable.UserID, UserID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}
