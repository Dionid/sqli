package db

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/Dionid/sqli"
)

type GooseDbVersionTable struct {
	sqli.Table
	ID        sqli.Column[int]
	VersionID sqli.Column[int64]
	IsApplied sqli.Column[bool]
	Tstamp    sqli.Column[time.Time]
}

func (t GooseDbVersionTable) As(alias string) GooseDbVersionTable {
	t.Table.TableAlias = fmt.Sprintf(`"%s"`, alias)
	t.ID = sqli.NewColumnWithAlias[int](t.Table, t.ID.ColumnName, t.ID.ColumnAlias)
	t.VersionID = sqli.NewColumnWithAlias[int64](t.Table, t.VersionID.ColumnName, t.VersionID.ColumnAlias)
	t.IsApplied = sqli.NewColumnWithAlias[bool](t.Table, t.IsApplied.ColumnName, t.IsApplied.ColumnAlias)
	t.Tstamp = sqli.NewColumnWithAlias[time.Time](t.Table, t.Tstamp.ColumnName, t.Tstamp.ColumnAlias)

	return t
}

var GooseDbVersionMeta = sqli.Table{
	TableName:  `"goose_db_version"`,
	TableAlias: `"goose_db_version"`,
}

var GooseDbVersion = GooseDbVersionTable{
	Table:     GooseDbVersionMeta,
	ID:        sqli.NewColumn[int](GooseDbVersionMeta, `"id"`),
	VersionID: sqli.NewColumn[int64](GooseDbVersionMeta, `"version_id"`),
	IsApplied: sqli.NewColumn[bool](GooseDbVersionMeta, `"is_applied"`),
	Tstamp:    sqli.NewColumn[time.Time](GooseDbVersionMeta, `"tstamp"`),
}

// # Constants

// # Columns Types
type (
	GooseDbVersionIDT        = int
	GooseDbVersionVersionIDT = int64
	GooseDbVersionIsAppliedT = bool
	GooseDbVersionTstampT    = time.Time
)

// # Columns Names
const (
	GooseDbVersionID        = `"id"`
	GooseDbVersionVersionID = `"version_id"`
	GooseDbVersionIsApplied = `"is_applied"`
	GooseDbVersionTstamp    = `"tstamp"`
)

// # Model

type GooseDbVersionModel struct {
	ID        int       `json:"id" db:"id"`
	VersionID int64     `json:"version_id" db:"version_id"`
	IsApplied bool      `json:"is_applied" db:"is_applied"`
	Tstamp    time.Time `json:"tstamp" db:"tstamp"`
}

func NewGooseDbVersionModel(
	ID int,
	VersionID int64,
	IsApplied bool,
	Tstamp time.Time,
) *GooseDbVersionModel {
	return &GooseDbVersionModel{
		ID:        ID,
		VersionID: VersionID,
		IsApplied: IsApplied,
		Tstamp:    Tstamp,
	}
}

// ## Insertable

type InsertableGooseDbVersionModel struct {
	VersionID int64     `json:"version_id" db:"version_id"`
	IsApplied bool      `json:"is_applied" db:"is_applied"`
	Tstamp    time.Time `json:"tstamp" db:"tstamp"`
}

func NewInsertableGooseDbVersionModel(
	VersionID int64,
	IsApplied bool,
	Tstamp time.Time,
) *InsertableGooseDbVersionModel {
	return &InsertableGooseDbVersionModel{
		VersionID: VersionID,
		IsApplied: IsApplied,
		Tstamp:    Tstamp,
	}
}

func InsertIntoGooseDbVersion(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableGooseDbVersionModel,
) (sql.Result, error) {
	if modelsList == nil {
		return nil, errors.New("InsertableGooseDbVersionModel is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(GooseDbVersion.VersionID, model.VersionID),
			sqli.VALUE(GooseDbVersion.IsApplied, model.IsApplied),
			sqli.VALUE(GooseDbVersion.Tstamp, model.Tstamp),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			GooseDbVersion,
			GooseDbVersion.VersionID,
			GooseDbVersion.IsApplied,
			GooseDbVersion.Tstamp,
		),
		sqli.VALUES(
			valueSetList...,
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoGooseDbVersionReturningAll(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableGooseDbVersionModel,
) (*GooseDbVersionModel, error) {
	if modelsList == nil {
		return nil, errors.New("InsertableGooseDbVersionModel is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(GooseDbVersion.VersionID, model.VersionID),
			sqli.VALUE(GooseDbVersion.IsApplied, model.IsApplied),
			sqli.VALUE(GooseDbVersion.Tstamp, model.Tstamp),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			GooseDbVersion,
			GooseDbVersion.VersionID,
			GooseDbVersion.IsApplied,
			GooseDbVersion.Tstamp,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(GooseDbVersion.AllColumns()),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var model GooseDbVersionModel
	err = row.Scan(
		&model.ID,
		&model.VersionID,
		&model.IsApplied,
		&model.Tstamp,
	)
	if err != nil {
		return nil, err
	}

	return &model, nil
}

// ## Updatable

type UpdatableGooseDbVersionModel struct {
	ID        *int       `json:"id" db:"id"`
	VersionID *int64     `json:"version_id" db:"version_id"`
	IsApplied *bool      `json:"is_applied" db:"is_applied"`
	Tstamp    *time.Time `json:"tstamp" db:"tstamp"`
}

func NewUpdatableGooseDbVersionModel(
	ID *int,
	VersionID *int64,
	IsApplied *bool,
	Tstamp *time.Time,
) *UpdatableGooseDbVersionModel {
	return &UpdatableGooseDbVersionModel{
		ID,
		VersionID,
		IsApplied,
		Tstamp,
	}
}

// ## Select by ID
func SelectGooseDbVersionByID(
	ctx context.Context,
	db DB,
	ID int,
) (*GooseDbVersionModel, error) {
	query, err := sqli.Query(
		sqli.SELECT(
			GooseDbVersion.AllColumns(),
		),
		sqli.FROM(GooseDbVersion),
		sqli.WHERE(
			sqli.EQUAL(GooseDbVersion.ID, ID),
		),
		sqli.LIMIT(1),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	model := &GooseDbVersionModel{}
	err = row.Scan(
		&model.ID,
		&model.VersionID,
		&model.IsApplied,
		&model.Tstamp,
	)
	if err != nil {
		return nil, err
	}

	return model, nil
}

// ## Delete by ID
func DeleteFromGooseDbVersionByID(
	ctx context.Context,
	db DB,
	ID int,
) (sql.Result, error) {
	query, err := sqli.Query(
		sqli.DELETE_FROM(
			GooseDbVersion,
		),
		sqli.WHERE(
			sqli.EQUAL(GooseDbVersion.ID, ID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoGooseDbVersionReturningID(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableGooseDbVersionModel,
) (*int, error) {
	if modelsList == nil {
		return nil, errors.New("InsertIntoGooseDbVersionReturningIDResult is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(GooseDbVersion.VersionID, model.VersionID),
			sqli.VALUE(GooseDbVersion.IsApplied, model.IsApplied),
			sqli.VALUE(GooseDbVersion.Tstamp, model.Tstamp),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			GooseDbVersion,
			GooseDbVersion.VersionID,
			GooseDbVersion.IsApplied,
			GooseDbVersion.Tstamp,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(
			GooseDbVersion.ID,
		),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var returning int
	err = row.Scan(&returning)
	if err != nil {
		return nil, err
	}

	return &returning, nil
}

// # Update
// ## Update by ID
func UpdateGooseDbVersionByID(
	ctx context.Context,
	db DB,
	ID int,
	updatableModel *UpdatableGooseDbVersionModel,
) (sql.Result, error) {
	valuesSetList := []sqli.Statement{}

	if updatableModel.ID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(GooseDbVersion.ID, *updatableModel.ID))
	}
	if updatableModel.VersionID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(GooseDbVersion.VersionID, *updatableModel.VersionID))
	}
	if updatableModel.IsApplied != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(GooseDbVersion.IsApplied, *updatableModel.IsApplied))
	}
	if updatableModel.Tstamp != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(GooseDbVersion.Tstamp, *updatableModel.Tstamp))
	}

	query, err := sqli.Query(
		sqli.UPDATE(
			GooseDbVersion,
		),
		sqli.SET(
			valuesSetList...,
		),
		sqli.WHERE(
			sqli.EQUAL(GooseDbVersion.ID, ID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}
