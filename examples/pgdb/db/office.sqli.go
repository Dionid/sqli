package db

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/Dionid/sqli"
	"github.com/google/uuid"
)

type OfficeTable struct {
	sqli.Table
	ID        sqli.Column[uuid.UUID]
	Name      sqli.Column[string]
	CreatedAt sqli.Column[time.Time]
	UpdatedAt sqli.Column[sql.NullTime]
}

func (t OfficeTable) As(alias string) OfficeTable {
	t.Table.TableAlias = fmt.Sprintf(`"%s"`, alias)
	t.ID = sqli.NewColumnWithAlias[uuid.UUID](t.Table, t.ID.ColumnName, t.ID.ColumnAlias)
	t.Name = sqli.NewColumnWithAlias[string](t.Table, t.Name.ColumnName, t.Name.ColumnAlias)
	t.CreatedAt = sqli.NewColumnWithAlias[time.Time](t.Table, t.CreatedAt.ColumnName, t.CreatedAt.ColumnAlias)
	t.UpdatedAt = sqli.NewColumnWithAlias[sql.NullTime](t.Table, t.UpdatedAt.ColumnName, t.UpdatedAt.ColumnAlias)

	return t
}

var OfficeMeta = sqli.Table{
	TableName:  `"office"`,
	TableAlias: `"office"`,
	ColumnNames: map[string]bool{
		`"id"`:         true,
		`"name"`:       true,
		`"created_at"`: true,
		`"updated_at"`: true,
	},
}

var Office = OfficeTable{
	Table:     OfficeMeta,
	ID:        sqli.NewColumn[uuid.UUID](OfficeMeta, `"id"`),
	Name:      sqli.NewColumn[string](OfficeMeta, `"name"`),
	CreatedAt: sqli.NewColumn[time.Time](OfficeMeta, `"created_at"`),
	UpdatedAt: sqli.NewColumn[sql.NullTime](OfficeMeta, `"updated_at"`),
}

// # Constants

// # Columns Types
type (
	OfficeIDT        = uuid.UUID
	OfficeNameT      = string
	OfficeCreatedAtT = time.Time
	OfficeUpdatedAtT = sql.NullTime
)

// # Columns Names
const (
	OfficeID        = `"id"`
	OfficeName      = `"name"`
	OfficeCreatedAt = `"created_at"`
	OfficeUpdatedAt = `"updated_at"`
)

// # Model

type OfficeModel struct {
	ID        uuid.UUID    `json:"id" db:"id"`
	Name      string       `json:"name" db:"name"`
	CreatedAt time.Time    `json:"created_at" db:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at" db:"updated_at"`
}

func NewOfficeModel(
	ID uuid.UUID,
	Name string,
	CreatedAt time.Time,
	UpdatedAt sql.NullTime,
) *OfficeModel {
	return &OfficeModel{
		ID:        ID,
		Name:      Name,
		CreatedAt: CreatedAt,
		UpdatedAt: UpdatedAt,
	}
}

// ## Insertable

type InsertableOfficeModel struct {
	ID        uuid.UUID    `json:"id" db:"id"`
	Name      string       `json:"name" db:"name"`
	CreatedAt time.Time    `json:"created_at" db:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at" db:"updated_at"`
}

func NewInsertableOfficeModel(
	ID uuid.UUID,
	Name string,
	CreatedAt time.Time,
	UpdatedAt sql.NullTime,
) *InsertableOfficeModel {
	return &InsertableOfficeModel{
		ID:        ID,
		Name:      Name,
		CreatedAt: CreatedAt,
		UpdatedAt: UpdatedAt,
	}
}

func InsertIntoOffice(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableOfficeModel,
) (sql.Result, error) {
	if modelsList == nil {
		return nil, errors.New("InsertableOfficeModel is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(Office.ID, model.ID),
			sqli.VALUE(Office.Name, model.Name),
			sqli.VALUE(Office.CreatedAt, model.CreatedAt),
			sqli.VALUE(Office.UpdatedAt, model.UpdatedAt),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			Office,
			Office.ID,
			Office.Name,
			Office.CreatedAt,
			Office.UpdatedAt,
		),
		sqli.VALUES(
			valueSetList...,
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoOfficeReturningAll(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableOfficeModel,
) (*OfficeModel, error) {
	if modelsList == nil {
		return nil, errors.New("InsertableOfficeModel is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(Office.ID, model.ID),
			sqli.VALUE(Office.Name, model.Name),
			sqli.VALUE(Office.CreatedAt, model.CreatedAt),
			sqli.VALUE(Office.UpdatedAt, model.UpdatedAt),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			Office,
			Office.ID,
			Office.Name,
			Office.CreatedAt,
			Office.UpdatedAt,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(Office.AllColumns()),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var model OfficeModel
	err = row.Scan(
		&model.ID,
		&model.Name,
		&model.CreatedAt,
		&model.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &model, nil
}

// ## Updatable

type UpdatableOfficeModel struct {
	ID        *uuid.UUID    `json:"id" db:"id"`
	Name      *string       `json:"name" db:"name"`
	CreatedAt *time.Time    `json:"created_at" db:"created_at"`
	UpdatedAt *sql.NullTime `json:"updated_at" db:"updated_at"`
}

func NewUpdatableOfficeModel(
	ID *uuid.UUID,
	Name *string,
	CreatedAt *time.Time,
	UpdatedAt *sql.NullTime,
) *UpdatableOfficeModel {
	return &UpdatableOfficeModel{
		ID,
		Name,
		CreatedAt,
		UpdatedAt,
	}
}

// ## Select by Name
func SelectOfficeByName(
	ctx context.Context,
	db DB,
	Name string,
) (*OfficeModel, error) {
	query, err := sqli.Query(
		sqli.SELECT(
			Office.AllColumns(),
		),
		sqli.FROM(Office),
		sqli.WHERE(
			sqli.EQUAL(Office.Name, Name),
		),
		sqli.LIMIT(1),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	model := &OfficeModel{}
	err = row.Scan(
		&model.ID,
		&model.Name,
		&model.CreatedAt,
		&model.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return model, nil
}

// ## Delete by Name
func DeleteFromOfficeByName(
	ctx context.Context,
	db DB,
	Name string,
) (sql.Result, error) {
	query, err := sqli.Query(
		sqli.DELETE_FROM(
			Office,
		),
		sqli.WHERE(
			sqli.EQUAL(Office.Name, Name),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoOfficeReturningName(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableOfficeModel,
) (*string, error) {
	if modelsList == nil {
		return nil, errors.New("InsertIntoOfficeReturningNameResult is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(Office.ID, model.ID),
			sqli.VALUE(Office.Name, model.Name),
			sqli.VALUE(Office.CreatedAt, model.CreatedAt),
			sqli.VALUE(Office.UpdatedAt, model.UpdatedAt),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			Office,
			Office.ID,
			Office.Name,
			Office.CreatedAt,
			Office.UpdatedAt,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(
			Office.Name,
		),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var returning string
	err = row.Scan(&returning)
	if err != nil {
		return nil, err
	}

	return &returning, nil
}

// # Update
// ## Update by Name
func UpdateOfficeByName(
	ctx context.Context,
	db DB,
	Name string,
	updatableModel *UpdatableOfficeModel,
) (sql.Result, error) {
	valuesSetList := []sqli.Statement{}

	if updatableModel.ID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(Office.ID, *updatableModel.ID))
	}
	if updatableModel.Name != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(Office.Name, *updatableModel.Name))
	}
	if updatableModel.CreatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(Office.CreatedAt, *updatableModel.CreatedAt))
	}
	if updatableModel.UpdatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(Office.UpdatedAt, *updatableModel.UpdatedAt))
	}

	query, err := sqli.Query(
		sqli.UPDATE(
			Office,
		),
		sqli.SET(
			valuesSetList...,
		),
		sqli.WHERE(
			sqli.EQUAL(Office.Name, Name),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

// ## Select by ID
func SelectOfficeByID(
	ctx context.Context,
	db DB,
	ID uuid.UUID,
) (*OfficeModel, error) {
	query, err := sqli.Query(
		sqli.SELECT(
			Office.AllColumns(),
		),
		sqli.FROM(Office),
		sqli.WHERE(
			sqli.EQUAL(Office.ID, ID),
		),
		sqli.LIMIT(1),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	model := &OfficeModel{}
	err = row.Scan(
		&model.ID,
		&model.Name,
		&model.CreatedAt,
		&model.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return model, nil
}

// ## Delete by ID
func DeleteFromOfficeByID(
	ctx context.Context,
	db DB,
	ID uuid.UUID,
) (sql.Result, error) {
	query, err := sqli.Query(
		sqli.DELETE_FROM(
			Office,
		),
		sqli.WHERE(
			sqli.EQUAL(Office.ID, ID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoOfficeReturningID(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableOfficeModel,
) (*uuid.UUID, error) {
	if modelsList == nil {
		return nil, errors.New("InsertIntoOfficeReturningIDResult is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(Office.ID, model.ID),
			sqli.VALUE(Office.Name, model.Name),
			sqli.VALUE(Office.CreatedAt, model.CreatedAt),
			sqli.VALUE(Office.UpdatedAt, model.UpdatedAt),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			Office,
			Office.ID,
			Office.Name,
			Office.CreatedAt,
			Office.UpdatedAt,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(
			Office.ID,
		),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var returning uuid.UUID
	err = row.Scan(&returning)
	if err != nil {
		return nil, err
	}

	return &returning, nil
}

// # Update
// ## Update by ID
func UpdateOfficeByID(
	ctx context.Context,
	db DB,
	ID uuid.UUID,
	updatableModel *UpdatableOfficeModel,
) (sql.Result, error) {
	valuesSetList := []sqli.Statement{}

	if updatableModel.ID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(Office.ID, *updatableModel.ID))
	}
	if updatableModel.Name != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(Office.Name, *updatableModel.Name))
	}
	if updatableModel.CreatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(Office.CreatedAt, *updatableModel.CreatedAt))
	}
	if updatableModel.UpdatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(Office.UpdatedAt, *updatableModel.UpdatedAt))
	}

	query, err := sqli.Query(
		sqli.UPDATE(
			Office,
		),
		sqli.SET(
			valuesSetList...,
		),
		sqli.WHERE(
			sqli.EQUAL(Office.ID, ID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}
