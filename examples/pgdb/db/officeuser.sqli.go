package db

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/Dionid/sqli"
	"github.com/google/uuid"
)

type OfficeUserTable struct {
	sqli.Table
	OfficeID  sqli.Column[uuid.UUID]
	UserID    sqli.Column[uuid.UUID]
	CreatedAt sqli.Column[time.Time]
	UpdatedAt sqli.Column[sql.NullTime]
}

func (t OfficeUserTable) As(alias string) OfficeUserTable {
	t.Table.TableAlias = fmt.Sprintf(`"%s"`, alias)
	t.OfficeID = sqli.NewColumnWithAlias[uuid.UUID](t.Table, t.OfficeID.ColumnName, t.OfficeID.ColumnAlias)
	t.UserID = sqli.NewColumnWithAlias[uuid.UUID](t.Table, t.UserID.ColumnName, t.UserID.ColumnAlias)
	t.CreatedAt = sqli.NewColumnWithAlias[time.Time](t.Table, t.CreatedAt.ColumnName, t.CreatedAt.ColumnAlias)
	t.UpdatedAt = sqli.NewColumnWithAlias[sql.NullTime](t.Table, t.UpdatedAt.ColumnName, t.UpdatedAt.ColumnAlias)

	return t
}

var OfficeUserMeta = sqli.Table{
	TableName:  `"office_user"`,
	TableAlias: `"office_user"`,
}

var OfficeUser = OfficeUserTable{
	Table:     OfficeUserMeta,
	OfficeID:  sqli.NewColumn[uuid.UUID](OfficeUserMeta, `"office_id"`),
	UserID:    sqli.NewColumn[uuid.UUID](OfficeUserMeta, `"user_id"`),
	CreatedAt: sqli.NewColumn[time.Time](OfficeUserMeta, `"created_at"`),
	UpdatedAt: sqli.NewColumn[sql.NullTime](OfficeUserMeta, `"updated_at"`),
}

// # Constants

// # Columns Types
type (
	OfficeUserOfficeIDT  = uuid.UUID
	OfficeUserUserIDT    = uuid.UUID
	OfficeUserCreatedAtT = time.Time
	OfficeUserUpdatedAtT = sql.NullTime
)

// # Columns Names
const (
	OfficeUserOfficeID  = `"office_id"`
	OfficeUserUserID    = `"user_id"`
	OfficeUserCreatedAt = `"created_at"`
	OfficeUserUpdatedAt = `"updated_at"`
)

// # Model

type OfficeUserModel struct {
	OfficeID  uuid.UUID    `json:"office_id" db:"office_id"`
	UserID    uuid.UUID    `json:"user_id" db:"user_id"`
	CreatedAt time.Time    `json:"created_at" db:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at" db:"updated_at"`
}

func NewOfficeUserModel(
	OfficeID uuid.UUID,
	UserID uuid.UUID,
	CreatedAt time.Time,
	UpdatedAt sql.NullTime,
) *OfficeUserModel {
	return &OfficeUserModel{
		OfficeID:  OfficeID,
		UserID:    UserID,
		CreatedAt: CreatedAt,
		UpdatedAt: UpdatedAt,
	}
}

// ## Insertable

type InsertableOfficeUserModel struct {
	OfficeID  uuid.UUID    `json:"office_id" db:"office_id"`
	UserID    uuid.UUID    `json:"user_id" db:"user_id"`
	CreatedAt time.Time    `json:"created_at" db:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at" db:"updated_at"`
}

func NewInsertableOfficeUserModel(
	OfficeID uuid.UUID,
	UserID uuid.UUID,
	CreatedAt time.Time,
	UpdatedAt sql.NullTime,
) *InsertableOfficeUserModel {
	return &InsertableOfficeUserModel{
		OfficeID:  OfficeID,
		UserID:    UserID,
		CreatedAt: CreatedAt,
		UpdatedAt: UpdatedAt,
	}
}

func InsertIntoOfficeUser(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableOfficeUserModel,
) (sql.Result, error) {
	if modelsList == nil {
		return nil, errors.New("InsertableOfficeUserModel is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(OfficeUser.OfficeID, model.OfficeID),
			sqli.VALUE(OfficeUser.UserID, model.UserID),
			sqli.VALUE(OfficeUser.CreatedAt, model.CreatedAt),
			sqli.VALUE(OfficeUser.UpdatedAt, model.UpdatedAt),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			OfficeUser,
			OfficeUser.OfficeID,
			OfficeUser.UserID,
			OfficeUser.CreatedAt,
			OfficeUser.UpdatedAt,
		),
		sqli.VALUES(
			valueSetList...,
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoOfficeUserReturningAll(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableOfficeUserModel,
) (*OfficeUserModel, error) {
	if modelsList == nil {
		return nil, errors.New("InsertableOfficeUserModel is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(OfficeUser.OfficeID, model.OfficeID),
			sqli.VALUE(OfficeUser.UserID, model.UserID),
			sqli.VALUE(OfficeUser.CreatedAt, model.CreatedAt),
			sqli.VALUE(OfficeUser.UpdatedAt, model.UpdatedAt),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			OfficeUser,
			OfficeUser.OfficeID,
			OfficeUser.UserID,
			OfficeUser.CreatedAt,
			OfficeUser.UpdatedAt,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(OfficeUser.AllColumns()),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var model OfficeUserModel
	err = row.Scan(
		&model.OfficeID,
		&model.UserID,
		&model.CreatedAt,
		&model.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &model, nil
}

// ## Updatable

type UpdatableOfficeUserModel struct {
	OfficeID  *uuid.UUID    `json:"office_id" db:"office_id"`
	UserID    *uuid.UUID    `json:"user_id" db:"user_id"`
	CreatedAt *time.Time    `json:"created_at" db:"created_at"`
	UpdatedAt *sql.NullTime `json:"updated_at" db:"updated_at"`
}

func NewUpdatableOfficeUserModel(
	OfficeID *uuid.UUID,
	UserID *uuid.UUID,
	CreatedAt *time.Time,
	UpdatedAt *sql.NullTime,
) *UpdatableOfficeUserModel {
	return &UpdatableOfficeUserModel{
		OfficeID,
		UserID,
		CreatedAt,
		UpdatedAt,
	}
}

// ## Select by compound
func SelectFromOfficeUserByOfficeIDUserID(
	ctx context.Context,
	db DB,
	OfficeID uuid.UUID,
	UserID uuid.UUID,
) (*OfficeUserModel, error) {
	query, err := sqli.Query(
		sqli.SELECT(
			OfficeUser.AllColumns(),
		),
		sqli.FROM(OfficeUser),
		sqli.WHERE(
			sqli.AND(
				sqli.EQUAL(OfficeUser.OfficeID, OfficeID),
				sqli.EQUAL(OfficeUser.UserID, UserID),
			),
		),
		sqli.LIMIT(1),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	model := &OfficeUserModel{}
	err = row.Scan(
		&model.OfficeID,
		&model.UserID,
		&model.CreatedAt,
		&model.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return model, nil
}

// ## Delete by compound
func DeleteFromOfficeUserByOfficeIDUserID(
	ctx context.Context,
	db DB,
	OfficeID uuid.UUID,
	UserID uuid.UUID,
) (sql.Result, error) {
	query, err := sqli.Query(
		sqli.DELETE_FROM(
			OfficeUser,
		),
		sqli.WHERE(
			sqli.AND(
				sqli.EQUAL(OfficeUser.OfficeID, OfficeID),
				sqli.EQUAL(OfficeUser.UserID, UserID),
			),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

// ## Update by compound
func UpdateOfficeUserByOfficeIDUserID(
	ctx context.Context,
	db DB,
	OfficeID uuid.UUID,
	UserID uuid.UUID,
	updatableModel *UpdatableOfficeUserModel,
) (sql.Result, error) {
	valuesSetList := []sqli.Statement{}

	if updatableModel.OfficeID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUser.OfficeID, *updatableModel.OfficeID))
	}
	if updatableModel.UserID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUser.UserID, *updatableModel.UserID))
	}
	if updatableModel.CreatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUser.CreatedAt, *updatableModel.CreatedAt))
	}
	if updatableModel.UpdatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUser.UpdatedAt, *updatableModel.UpdatedAt))
	}

	query, err := sqli.Query(
		sqli.UPDATE(
			OfficeUser,
		),
		sqli.SET(
			valuesSetList...,
		),
		sqli.WHERE(
			sqli.AND(
				sqli.EQUAL(OfficeUser.OfficeID, OfficeID),
				sqli.EQUAL(OfficeUser.UserID, UserID),
			),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

type InsertIntoOfficeUserReturningOfficeIDUserIDResult struct {
	OfficeID uuid.UUID `json:"office_id" db:"office_id"`
	UserID   uuid.UUID `json:"user_id" db:"user_id"`
}

func InsertIntoOfficeUserReturningOfficeIDUserID(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableOfficeUserModel,
) (*InsertIntoOfficeUserReturningOfficeIDUserIDResult, error) {
	if modelsList == nil {
		return nil, errors.New("InsertIntoOfficeUserReturningOfficeIDUserIDResult is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(OfficeUser.OfficeID, model.OfficeID),
			sqli.VALUE(OfficeUser.UserID, model.UserID),
			sqli.VALUE(OfficeUser.CreatedAt, model.CreatedAt),
			sqli.VALUE(OfficeUser.UpdatedAt, model.UpdatedAt),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			OfficeUser,
			OfficeUser.OfficeID,
			OfficeUser.UserID,
			OfficeUser.CreatedAt,
			OfficeUser.UpdatedAt,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(
			OfficeUser.OfficeID,
			OfficeUser.UserID,
		),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	returning := &InsertIntoOfficeUserReturningOfficeIDUserIDResult{}
	err = row.Scan(returning)
	if err != nil {
		return nil, err
	}

	return returning, nil
}

// ## Select by OfficeID
func SelectOfficeUserByOfficeID(
	ctx context.Context,
	db DB,
	OfficeID uuid.UUID,
) ([]*OfficeUserModel, error) {
	query, err := sqli.Query(
		sqli.SELECT(
			OfficeUser.AllColumns(),
		),
		sqli.FROM(OfficeUser),
		sqli.WHERE(
			sqli.EQUAL(OfficeUser.OfficeID, OfficeID),
		),
	)
	if err != nil {
		return nil, err
	}

	rows, err := db.QueryxContext(ctx, query.SQL, query.Args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*OfficeUserModel
	for rows.Next() {
		item := &OfficeUserModel{}
		if err := rows.Scan(
			item,
		); err != nil {
			return nil, err
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// ## Select by UserID
func SelectOfficeUserByUserID(
	ctx context.Context,
	db DB,
	UserID uuid.UUID,
) ([]*OfficeUserModel, error) {
	query, err := sqli.Query(
		sqli.SELECT(
			OfficeUser.AllColumns(),
		),
		sqli.FROM(OfficeUser),
		sqli.WHERE(
			sqli.EQUAL(OfficeUser.UserID, UserID),
		),
	)
	if err != nil {
		return nil, err
	}

	rows, err := db.QueryxContext(ctx, query.SQL, query.Args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*OfficeUserModel
	for rows.Next() {
		item := &OfficeUserModel{}
		if err := rows.Scan(
			item,
		); err != nil {
			return nil, err
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// ## Delete by OfficeID
func DeleteFromOfficeUserByOfficeID(
	ctx context.Context,
	db DB,
	OfficeID uuid.UUID,
) (sql.Result, error) {
	query, err := sqli.Query(
		sqli.DELETE_FROM(
			OfficeUser,
		),
		sqli.WHERE(
			sqli.EQUAL(OfficeUser.OfficeID, OfficeID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoOfficeUserReturningOfficeID(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableOfficeUserModel,
) (*uuid.UUID, error) {
	if modelsList == nil {
		return nil, errors.New("InsertIntoOfficeUserReturningOfficeIDUserIDResult is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(OfficeUser.OfficeID, model.OfficeID),
			sqli.VALUE(OfficeUser.UserID, model.UserID),
			sqli.VALUE(OfficeUser.CreatedAt, model.CreatedAt),
			sqli.VALUE(OfficeUser.UpdatedAt, model.UpdatedAt),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			OfficeUser,
			OfficeUser.OfficeID,
			OfficeUser.UserID,
			OfficeUser.CreatedAt,
			OfficeUser.UpdatedAt,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(
			OfficeUser.OfficeID,
		),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var returning uuid.UUID
	err = row.Scan(&returning)
	if err != nil {
		return nil, err
	}

	return &returning, nil
}

// # Update
// ## Update by OfficeID
func UpdateOfficeUserByOfficeID(
	ctx context.Context,
	db DB,
	OfficeID uuid.UUID,
	updatableModel *UpdatableOfficeUserModel,
) (sql.Result, error) {
	valuesSetList := []sqli.Statement{}

	if updatableModel.OfficeID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUser.OfficeID, *updatableModel.OfficeID))
	}
	if updatableModel.UserID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUser.UserID, *updatableModel.UserID))
	}
	if updatableModel.CreatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUser.CreatedAt, *updatableModel.CreatedAt))
	}
	if updatableModel.UpdatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUser.UpdatedAt, *updatableModel.UpdatedAt))
	}

	query, err := sqli.Query(
		sqli.UPDATE(
			OfficeUser,
		),
		sqli.SET(
			valuesSetList...,
		),
		sqli.WHERE(
			sqli.EQUAL(OfficeUser.OfficeID, OfficeID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

// ## Delete by UserID
func DeleteFromOfficeUserByUserID(
	ctx context.Context,
	db DB,
	UserID uuid.UUID,
) (sql.Result, error) {
	query, err := sqli.Query(
		sqli.DELETE_FROM(
			OfficeUser,
		),
		sqli.WHERE(
			sqli.EQUAL(OfficeUser.UserID, UserID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}

func InsertIntoOfficeUserReturningUserID(
	ctx context.Context,
	db DB,
	modelsList ...*InsertableOfficeUserModel,
) (*uuid.UUID, error) {
	if modelsList == nil {
		return nil, errors.New("InsertIntoOfficeUserReturningOfficeIDUserIDResult is nil")
	}

	valueSetList := make([]sqli.ValuesSetSt, len(modelsList))

	for i, model := range modelsList {
		if model == nil {
			return nil, errors.New("InsertableUserModel is nil")
		}

		valueSetList[i] = sqli.ValueSet(
			sqli.VALUE(OfficeUser.OfficeID, model.OfficeID),
			sqli.VALUE(OfficeUser.UserID, model.UserID),
			sqli.VALUE(OfficeUser.CreatedAt, model.CreatedAt),
			sqli.VALUE(OfficeUser.UpdatedAt, model.UpdatedAt),
		)
	}

	query, err := sqli.Query(
		sqli.INSERT_INTO(
			OfficeUser,
			OfficeUser.OfficeID,
			OfficeUser.UserID,
			OfficeUser.CreatedAt,
			OfficeUser.UpdatedAt,
		),
		sqli.VALUES(
			valueSetList...,
		),
		sqli.RETURNING(
			OfficeUser.UserID,
		),
	)
	if err != nil {
		return nil, err
	}

	row := db.QueryRowxContext(ctx, query.SQL, query.Args...)
	var returning uuid.UUID
	err = row.Scan(&returning)
	if err != nil {
		return nil, err
	}

	return &returning, nil
}

// # Update
// ## Update by UserID
func UpdateOfficeUserByUserID(
	ctx context.Context,
	db DB,
	UserID uuid.UUID,
	updatableModel *UpdatableOfficeUserModel,
) (sql.Result, error) {
	valuesSetList := []sqli.Statement{}

	if updatableModel.OfficeID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUser.OfficeID, *updatableModel.OfficeID))
	}
	if updatableModel.UserID != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUser.UserID, *updatableModel.UserID))
	}
	if updatableModel.CreatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUser.CreatedAt, *updatableModel.CreatedAt))
	}
	if updatableModel.UpdatedAt != nil {
		valuesSetList = append(valuesSetList, sqli.SET_VALUE(OfficeUser.UpdatedAt, *updatableModel.UpdatedAt))
	}

	query, err := sqli.Query(
		sqli.UPDATE(
			OfficeUser,
		),
		sqli.SET(
			valuesSetList...,
		),
		sqli.WHERE(
			sqli.EQUAL(OfficeUser.UserID, UserID),
		),
	)
	if err != nil {
		return nil, err
	}

	return db.ExecContext(ctx, query.SQL, query.Args...)
}
