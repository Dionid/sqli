# SQLi

Type-safe generative SQL Query Builder based on you DB schema.

```go

// SQLi generates Predefined Queries

newUserId := uuid.MustParse("ebb5dd71-1214-40dc-b602-bb9af74b3aae")

id, err := InsertIntoUserTableReturningID( // This is a generated function
    ctx,
    db,
    yourdb.InsertableUserModel{ 
        ID: newUserId,
        Name: "User 1",
    },
)

println(id) // ebb5dd71-1214-40dc-b602-bb9af74b3aae

// ... and you can also use Dynamic Queries

insertQuery, err := sqli.Query(
    sqli.INSERT_INTO(yourdb.UserTable),
    sqli.VALUES(
        sqli.ValueSet(
            VALUE(yourdb.UserTable.ID, newUserId), // VALUE function will validate the value UUID type
            VALUE(yourdb.UserTable.Name, "User 1"), // And this will validate the value string type
        ),
    ),
    sqli.RETURNING(
        yourdb.UserTable.ID,
    ),
)

println(insertQuery.SQL) // `INSERT INTO "user" (VALUES ($1, $2));`
println(insertQuery.Args) // [ebb5dd71-1214-40dc-b602-bb9af74b3aae, User 1]

row := db.QueryRowxContext(ctx, insertQuery.SQL, insertQuery.Args...)

var id uuid.UUID
err = row.Scan(&id)

println(id) // ebb5dd71-1214-40dc-b602-bb9af74b3aae

```

# Features

SQLi generates:

1. Constants
1. Predefined Queries
3. Dynamic Queries

## Predefined Queries

```go

// All of this functions are automatically generated by SQLi from your schema

// Lets insert some data

newUserId := uuid.MustParse("ebb5dd71-1214-40dc-b602-bb9af74b3aae")

id, err := InsertIntoUserTableReturningID(
	ctx,
	db,
    InsertableUserModel{
        ID: newUserId,
        Name: "User 1",
    },
)

println(id) // ebb5dd71-1214-40dc-b602-bb9af74b3aae

// Not lets select it by primary key

userByPrimaryKey, err := SelectUserTableByID(
    ctx,
    db,
    id,
)

println(userByPrimaryKey) // {ID: "ebb5dd71-1214-40dc-b602-bb9af74b3aae", Name: "User 1"}

// Now lets update it

err = UpdateUserTableByID(
    ctx,
    db,
    id,
    UpdatableOfficeModel{
        Name: "Updated User 1",
    }
)

// And delete

err = DeleteFromUserTableByID(
    ctx,
    db,
    id,
)


```

## Dynamic Queries

```go

// Insert user

newUserId := uuid.MustParse("ebb5dd71-1214-40dc-b602-bb9af74b3aae")

insertQuery, err := Query(
    INSERT_INTO(UserTable),
    VALUES(
        ValueSet(
            VALUE(UserTable.ID, newUserId), // VALUE function will validate the value UUID type
            VALUE(UserTable.Name, "User 1"), // And this will validate the value string type
        ),
    ),
    RETURNING(
        UserTable.ID,
    ),
)

// `insertQuery` will have raw SQL and raw arguments, that can be used to execute the query

println(insertQuery.SQL) // `INSERT INTO "user" (VALUES ($1, $2));`
println(insertQuery.Args) // [ebb5dd71-1214-40dc-b602-bb9af74b3aae, User 1]

// Now lets execute the query

row := db.QueryRowxContext(ctx, insertQuery.SQL, insertQuery.Args...)

var id uuid.UUID
err = row.Scan(&id)

println(id) // ebb5dd71-1214-40dc-b602-bb9af74b3aae

// Select it by primary key

selectQuery, err := Query(
    SELECT(
        UserTable.AllColumns(), // *
    ),
    FROM(UserTable),
    WHERE(
        EQUAL(UserTable.ID, id),
    ),
)

println(selectQuery.SQL) // SELECT * FROM "user" AS "user" WHERE "user"."id" = $1;
println(selectQuery.Args) // [ebb5dd71-1214-40dc-b602-bb9af74b3aae]

row := db.QueryRowxContext(ctx, selectQuery.SQL, selectQuery.Args...)
user := &UserModel{} // Also generated by SQLi
err = row.Scan(
    &user.ID,
    &user.Name,
)
println(user) // {ID: "ebb5dd71-1214-40dc-b602-bb9af74b3aae", Name: "User 1"}

// Now lets update it

query, err := Query(
    UPDATE(UserTable),
    SET(
        SET_VALUE(UserTable.Name, "Updated User 1"),
    ),
    WHERE(
        EQUAL(UserTable.ID, id),
    ),
)

println(query.SQL) // UPDATE "user" SET "user"."name" = $1 WHERE "user"."id" = $2;
println(query.Args) // [Updated User 1, ebb5dd71-1214-40dc-b602-bb9af74b3aae]

row := db.ExecContext(ctx, query.SQL, query.Args...)
println(row.RowsAffected()) // 1

// And delete

query, err := Query(
    DELETE_FROM(UserTable),
    WHERE(
        EQUAL(UserTable.ID, id),
    ),
)

println(query.SQL) // DELETE FROM "user" WHERE "user"."id" = $1;
println(query.Args) // [ebb5dd71-1214-40dc-b602-bb9af74b3aae]

row := db.ExecContext(ctx, query.SQL, query.Args...)
println(row.RowsAffected()) // 1

```

# Predefined Queries

Set of already predefined queries.

## Insert

1. Returning Result
1. Returning All
1. Returning Primary key
1. Returning Unique key

## Select By

1. Primary
1. By Primary compound
1. Sequence

## Delete By

1. Primary
1. By Primary compound
1. Sequence

## Update

1. By Primary
1. By Primary compound
1. By Sequence

# Dynamic Type-safe Queries

...

# Examples

For more examples, see the [examples](./examples) folder.

# TODO

1. pgx types
1. Upsert
1. SUM
1. JSON_AGG
1. InsertReturning
1. InsertOnConflict
1. CopySimple
